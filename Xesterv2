-- Xester V2 Addon for GGCMD
-- Execute only after GGCMD has already been executed.

local Players = game:GetService("Players")
local Debris = game:GetService("Debris")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TextChatService = game:GetService("TextChatService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local localPlayer = Players.LocalPlayer
local playerGui = localPlayer:FindFirstChildOfClass("PlayerGui") or localPlayer:WaitForChild("PlayerGui", 10)
local ggcmdGui = playerGui and playerGui:FindFirstChild("GGCMD")
local genv = (getgenv and getgenv()) or _G

if not ggcmdGui then
	warn("[Xester V2] GGCMD not found. Execute GGCMD first.")
	return
end

if not genv.foundRemote then
	warn("[Xester V2] GGCMD remote missing (getgenv().foundRemote). Execute GGCMD first.")
	return
end

local PREFIX = ";"
local TAG = "GGCMD_XESTER_V2"

local state = {
	connections = {},
	effects = {},
	tools = {},
	minion = nil,
	minionUsed = false
}

local function notify(title, text, duration)
	pcall(function()
		game:GetService("StarterGui"):SetCore("SendNotification", {
			Title = title,
			Text = text,
			Duration = duration or 3
		})
	end)
end

local function sendGGCMDCommand(raw)
	local msg = PREFIX .. raw
	if TextChatService.ChatVersion == Enum.ChatVersion.TextChatService then
		local channel = TextChatService.TextChannels:FindFirstChild("RBXGeneral")
		if channel then
			pcall(function()
				channel:SendAsync(msg)
			end)
			return
		end
	end

	local legacy = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
	local say = legacy and legacy:FindFirstChild("SayMessageRequest")
	if say then
		pcall(function()
			say:FireServer(msg, "All")
		end)
	end
end

local function track(inst, life)
	table.insert(state.effects, inst)
	if life and life > 0 then
		Debris:AddItem(inst, life)
	end
	return inst
end

local function cleanupEffects()
	for _, v in ipairs(state.effects) do
		if v and v.Parent then
			v:Destroy()
		end
	end
	table.clear(state.effects)
end

local function getChar()
	local char = localPlayer.Character or localPlayer.CharacterAdded:Wait()
	local hum = char:FindFirstChildOfClass("Humanoid")
	local hrp = char:FindFirstChild("HumanoidRootPart")
	return char, hum, hrp
end

local function nearestTarget(maxDistance)
	local _, _, hrp = getChar()
	if not hrp then return nil end

	local bestPlr, bestDist = nil, maxDistance
	for _, plr in ipairs(Players:GetPlayers()) do
		if plr == localPlayer then continue end
		local c = plr.Character
		local h = c and c:FindFirstChildOfClass("Humanoid")
		local root = c and c:FindFirstChild("HumanoidRootPart")
		if root and h and h.Health > 0 then
			local d = (root.Position - hrp.Position).Magnitude
			if d < bestDist then
				bestDist = d
				bestPlr = plr
			end
		end
	end
	return bestPlr
end

local function createFlyingCardsAura()
	local char, _, hrp = getChar()
	if not char or not hrp then return end

	for i = 1, 6 do
		local card = track(Instance.new("Part"))
		card.Name = TAG .. "_AuraCard"
		card.Anchored = true
		card.CanCollide = false
		card.Material = Enum.Material.Neon
		card.Color = (i % 2 == 0) and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(25, 25, 25)
		card.Size = Vector3.new(1.2, 0.08, 1.8)
		card.Parent = workspace

		local tl = Instance.new("SurfaceGui")
		tl.SizingMode = Enum.SurfaceGuiSizingMode.PixelsPerStud
		tl.PixelsPerStud = 50
		tl.Face = Enum.NormalId.Top
		tl.Parent = card
		local t = Instance.new("TextLabel")
		t.BackgroundTransparency = 1
		t.Size = UDim2.fromScale(1, 1)
		t.Font = Enum.Font.GothamBold
		t.TextScaled = true
		t.Text = (i % 2 == 0) and "♠" or "♥"
		t.TextColor3 = (i % 2 == 0) and Color3.fromRGB(220, 50, 50) or Color3.fromRGB(240, 240, 240)
		t.Parent = tl

		local angle = (math.pi * 2 / 6) * i
		table.insert(state.connections, RunService.RenderStepped:Connect(function()
			if not hrp.Parent then return end
			local tNow = tick() * 1.2
			local radius = 3.6
			local offset = Vector3.new(math.cos(tNow + angle) * radius, 1.2 + math.sin(tNow * 2 + angle) * 0.4, math.sin(tNow + angle) * radius)
			card.CFrame = CFrame.new(hrp.Position + offset) * CFrame.Angles(0, tNow * 2.2, math.rad(90))
		end))
	end
end

local function applyJesterLook()
	local char, hum = getChar()
	if not char or not hum then return end

	pcall(function()
		local desc = hum:GetAppliedDescription()
		desc.Shirt = 7192553840
		desc.Pants = 7192555714
		desc.Face = 7074764
		desc.HatAccessory = "439946249,62234425"
		hum:ApplyDescription(desc)
	end)

	local floatBV = Instance.new("BodyVelocity")
	floatBV.Name = TAG .. "_Float"
	floatBV.MaxForce = Vector3.new(0, 14000, 0)
	floatBV.Velocity = Vector3.new(0, 2.2, 0)
	floatBV.Parent = char:FindFirstChild("HumanoidRootPart") or char
	track(floatBV)

	table.insert(state.connections, RunService.Heartbeat:Connect(function()
		if floatBV.Parent then
			floatBV.Velocity = Vector3.new(0, 1.8 + math.sin(tick() * 2.8) * 1.3, 0)
		end
	end))

	notify("Xester V2", "Jester look + floating aura enabled", 3)
end

local function tryDamageTarget(target, fallbackDamageText)
	if not target then return end
	sendGGCMDCommand("fling " .. target.Name)
	notify("Xester V2", fallbackDamageText .. " on " .. target.Name, 2)
end

local function cardBlackHole()
	local _, _, hrp = getChar()
	if not hrp then return end
	local target = nearestTarget(35)

	local hole = track(Instance.new("Part"), 2.5)
	hole.Anchored = true
	hole.CanCollide = false
	hole.Shape = Enum.PartType.Cylinder
	hole.Material = Enum.Material.Neon
	hole.Color = Color3.fromRGB(10, 10, 10)
	hole.Size = Vector3.new(0.2, 0.2, 0.2)
	hole.CFrame = CFrame.new(hrp.Position + hrp.CFrame.LookVector * 8) * CFrame.Angles(0, 0, math.rad(90))
	hole.Parent = workspace

	local goal = {Size = Vector3.new(16, 0.4, 16)}
	TweenService:Create(hole, TweenInfo.new(0.2, Enum.EasingStyle.Quad), goal):Play()

	for i = 1, 5 do
		task.delay(i * 0.1, function()
			if not hole.Parent then return end
			hole.CFrame *= CFrame.Angles(0, math.rad(90), 0)
			for _, plr in ipairs(Players:GetPlayers()) do
				if plr == localPlayer then continue end
				local c = plr.Character
				local root = c and c:FindFirstChild("HumanoidRootPart")
				if root then
					local d = (root.Position - hole.Position).Magnitude
					if d < 20 then
						local pullDir = (hole.Position - root.Position)
						if pullDir.Magnitude > 0.01 then
							root.AssemblyLinearVelocity = pullDir.Unit * 90
						end
					end
				end
			end
		end)
	end

	tryDamageTarget(target, "Card Black Hole (20-25)")
end

local function superiorLightning()
	local _, _, hrp = getChar()
	if not hrp then return end
	local target = nearestTarget(120)
	if not target then
		notify("Superior Lightning", "No target found", 2)
		return
	end

	local tRoot = target.Character and target.Character:FindFirstChild("HumanoidRootPart")
	if not tRoot then return end

	for i = 1, 3 do
		local bolt = track(Instance.new("Part"), 0.35)
		bolt.Anchored = true
		bolt.CanCollide = false
		bolt.Material = Enum.Material.Neon
		bolt.Color = Color3.fromRGB(120, 175, 255)
		bolt.Size = Vector3.new(0.4, 10, 0.4)
		bolt.CFrame = CFrame.new(tRoot.Position + Vector3.new(math.random(-2, 2), 6, math.random(-2, 2)))
		bolt.Parent = workspace
	end

	tryDamageTarget(target, "Superior Lightning (25)")
end

local function superiorBomb()
	local _, _, hrp = getChar()
	if not hrp then return end
	local target = nearestTarget(40)

	for _, plr in ipairs(Players:GetPlayers()) do
		if plr == localPlayer then continue end
		local root = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
		if root and (root.Position - hrp.Position).Magnitude < 24 then
			local pullDir = (hrp.Position - root.Position)
			if pullDir.Magnitude > 0.01 then
				root.AssemblyLinearVelocity = pullDir.Unit * 120 + Vector3.new(0, 30, 0)
			end
		end
	end

	local blast = track(Instance.new("Explosion"))
	blast.Position = hrp.Position + hrp.CFrame.LookVector * 4
	blast.BlastRadius = 10
	blast.BlastPressure = 0
	blast.DestroyJointRadiusPercent = 0
	blast.Parent = workspace

	tryDamageTarget(target, "Superior Bomb (100)")
end

local function minionThink(minionModel)
	while minionModel and minionModel.Parent do
		task.wait(0.22)
		local minionRoot = minionModel:FindFirstChild("HumanoidRootPart")
		local hum = minionModel:FindFirstChildOfClass("Humanoid")
		if not minionRoot or not hum or hum.Health <= 0 then break end

		local closest, d = nil, 60
		for _, plr in ipairs(Players:GetPlayers()) do
			if plr == localPlayer then continue end
			local root = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
			local ph = plr.Character and plr.Character:FindFirstChildOfClass("Humanoid")
			if root and ph and ph.Health > 0 then
				local dist = (root.Position - minionRoot.Position).Magnitude
				if dist < d then
					d = dist
					closest = plr
				end
			end
		end

		if closest then
			local tRoot = closest.Character and closest.Character:FindFirstChild("HumanoidRootPart")
			if tRoot then
				hum:MoveTo(tRoot.Position)
				if (tRoot.Position - minionRoot.Position).Magnitude < 6 then
					tRoot.AssemblyLinearVelocity = (tRoot.Position - minionRoot.Position).Unit * 80 + Vector3.new(0, 40, 0)
					tryDamageTarget(closest, "Minion Hammer (50)")
					task.wait(1)
				end
			end
		end
	end
end

local function spawnMinion()
	if state.minionUsed then
		notify("Xester Minion", "Can only use once per death", 3)
		return
	end

	local _, _, hrp = getChar()
	if not hrp then return end

	state.minionUsed = true

	local model = Instance.new("Model")
	model.Name = TAG .. "_Minion"
	model.Parent = workspace

	local root = Instance.new("Part")
	root.Name = "HumanoidRootPart"
	root.Size = Vector3.new(2, 2, 1)
	root.Position = hrp.Position + hrp.CFrame.RightVector * 4
	root.Parent = model

	local torso = Instance.new("Part")
	torso.Name = "Torso"
	torso.Size = Vector3.new(2, 2, 1)
	torso.Position = root.Position
	torso.Parent = model

	local head = Instance.new("Part")
	head.Name = "Head"
	head.Size = Vector3.new(2, 1, 1)
	head.Position = root.Position + Vector3.new(0, 1.5, 0)
	head.Parent = model

	local hum = Instance.new("Humanoid")
	hum.WalkSpeed = 22
	hum.MaxHealth = 300
	hum.Health = 300
	hum.Parent = model

	local weld1 = Instance.new("WeldConstraint")
	weld1.Part0 = root
	weld1.Part1 = torso
	weld1.Parent = root

	local weld2 = Instance.new("WeldConstraint")
	weld2.Part0 = torso
	weld2.Part1 = head
	weld2.Parent = torso

	local hammer = Instance.new("Part")
	hammer.Name = "Hammer"
	hammer.Size = Vector3.new(1, 4, 1)
	hammer.Material = Enum.Material.Metal
	hammer.Color = Color3.fromRGB(55, 55, 55)
	hammer.Position = root.Position + Vector3.new(1.8, 0.5, 0)
	hammer.Parent = model
	local weld3 = Instance.new("WeldConstraint")
	weld3.Part0 = torso
	weld3.Part1 = hammer
	weld3.Parent = hammer

	state.minion = model
	track(model)
	task.spawn(minionThink, model)
	notify("Xester Minion", "Minion spawned", 2)
end

local function makeTool(name, color, onActivated)
	local tool = Instance.new("Tool")
	tool.RequiresHandle = true
	tool.Name = name

	local handle = Instance.new("Part")
	handle.Name = "Handle"
	handle.Size = Vector3.new(1, 1, 1)
	handle.Material = Enum.Material.Neon
	handle.Color = color
	handle.Parent = tool

	tool.Activated:Connect(onActivated)
	tool.Parent = localPlayer.Backpack
	table.insert(state.tools, tool)
end

local function clearTools()
	for _, t in ipairs(state.tools) do
		if t and t.Parent then
			t:Destroy()
		end
	end
	table.clear(state.tools)
end

local function resetOnRespawn()
	state.minionUsed = false
	if state.minion and state.minion.Parent then
		state.minion:Destroy()
	end
	state.minion = nil

	clearTools()
	task.wait(0.4)

	makeTool("Card Black Hole", Color3.fromRGB(25, 25, 25), cardBlackHole)
	makeTool("Superior Lightning", Color3.fromRGB(120, 175, 255), superiorLightning)
	makeTool("Superior Bomb", Color3.fromRGB(255, 120, 60), superiorBomb)
	makeTool("Ability Minion", Color3.fromRGB(255, 55, 120), spawnMinion)

	applyJesterLook()
	createFlyingCardsAura()
end

for _, c in ipairs(state.connections) do
	c:Disconnect()
end
state.connections = {}
cleanupEffects()

resetOnRespawn()

table.insert(state.connections, localPlayer.CharacterAdded:Connect(function()
	cleanupEffects()
	for _, c in ipairs(state.connections) do
		if c.Connected then
			c:Disconnect()
		end
	end
	state.connections = {}
	task.wait(1)
	resetOnRespawn()
end))

table.insert(state.connections, UserInputService.InputBegan:Connect(function(input, gp)
	if gp then return end
	if input.KeyCode == Enum.KeyCode.E then
		cardBlackHole()
	elseif input.KeyCode == Enum.KeyCode.Y then
		superiorLightning()
	end
end))

notify("Xester V2", "Loaded: 4 tools + E/Y key abilities", 4)
