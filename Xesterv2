-- Xester V2 addon for GGCMD
-- Execute after GGCMD. Adds click tools + keybind abilities.

local Players = game:GetService("Players")
local Debris = game:GetService("Debris")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TextChatService = game:GetService("TextChatService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local localPlayer = Players.LocalPlayer
local genv = (getgenv and getgenv()) or _G

local playerGui = localPlayer:FindFirstChildOfClass("PlayerGui") or localPlayer:WaitForChild("PlayerGui", 10)
local ggcmdGui = playerGui and playerGui:FindFirstChild("GGCMD")
if not ggcmdGui or not genv.foundRemote then
	warn("[XesterV2] GGCMD not found. Execute GGCMD first.")
	return
end

local state = {
	tools = {},
	effects = {},
	floatCon = nil,
	cardsCon = nil,
	lifeMinionUsed = false,
	lightningKey = Enum.KeyCode.Y
}

local function notify(title, text, duration)
	pcall(function()
		game:GetService("StarterGui"):SetCore("SendNotification", {
			Title = title,
			Text = text,
			Duration = duration or 3
		})
	end)
end

local function sendGGCMDCommand(raw)
	local msg = ";" .. raw
	if TextChatService.ChatVersion == Enum.ChatVersion.TextChatService then
		local channel = TextChatService.TextChannels:FindFirstChild("RBXGeneral")
		if channel then
			pcall(function() channel:SendAsync(msg) end)
			return
		end
	end
	local legacy = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
	local say = legacy and legacy:FindFirstChild("SayMessageRequest")
	if say then
		pcall(function() say:FireServer(msg, "All") end)
	end
end

local function deleteViaGGCMD(instance)
	if not instance or not instance.Parent or not genv.foundRemote then return false end
	local ok = pcall(function()
		genv.foundRemote:FireServer(instance, nil)
	end)
	return ok
end

local function addEffect(inst, life)
	table.insert(state.effects, inst)
	if life and life > 0 then
		Debris:AddItem(inst, life)
	end
	return inst
end

local function getCharacter()
	local c = localPlayer.Character or localPlayer.CharacterAdded:Wait()
	local hum = c:FindFirstChildOfClass("Humanoid")
	local hrp = c:FindFirstChild("HumanoidRootPart")
	return c, hum, hrp
end

local function getTargetFromMouse(maxDistance)
	local _, _, hrp = getCharacter()
	if not hrp then return end
	local mouse = localPlayer:GetMouse()
	local hitPos = mouse.Hit and mouse.Hit.Position
	if not hitPos then return end

	local best, bestRoot, bestHum, bestDist
	for _, plr in ipairs(Players:GetPlayers()) do
		if plr == localPlayer then continue end
		local char = plr.Character
		local hum = char and char:FindFirstChildOfClass("Humanoid")
		local root = char and char:FindFirstChild("HumanoidRootPart")
		if hum and hum.Health > 0 and root then
			local dAim = (root.Position - hitPos).Magnitude
			local dSelf = (root.Position - hrp.Position).Magnitude
			if dSelf <= maxDistance and (not bestDist or dAim < bestDist) then
				best, bestRoot, bestHum, bestDist = plr, root, hum, dAim
			end
		end
	end

	for _, model in ipairs(workspace:GetDescendants()) do
		if not model:IsA("Model") then continue end
		if model:FindFirstChildWhichIsA("Player") then continue end
		local hum = model:FindFirstChildOfClass("Humanoid")
		local root = model:FindFirstChild("HumanoidRootPart") or model:FindFirstChild("Torso") or model:FindFirstChild("UpperTorso")
		if hum and hum.Health > 0 and root then
			local dAim = (root.Position - hitPos).Magnitude
			local dSelf = (root.Position - hrp.Position).Magnitude
			if dSelf <= maxDistance and (not bestDist or dAim < bestDist) then
				best, bestRoot, bestHum, bestDist = model, root, hum, dAim
			end
		end
	end

	return best, bestRoot, bestHum
end

local function applyXesterStyle()
	sendGGCMDCommand("blockhats me")
	sendGGCMDCommand("bighead me")

	local char = localPlayer.Character
	if not char then return end
	for _, p in ipairs(char:GetDescendants()) do
		if p:IsA("BasePart") and p.Name ~= "HumanoidRootPart" then
			p.Color = Color3.fromRGB(69, 0, 102)
		end
	end
end

local function startFloatingAndCards()
	if state.floatCon then state.floatCon:Disconnect() end
	if state.cardsCon then state.cardsCon:Disconnect() end

	local char, _, hrp = getCharacter()
	if not char or not hrp then return end

	local t = 0
	state.floatCon = RunService.Heartbeat:Connect(function(dt)
		t += dt
		hrp.AssemblyLinearVelocity = Vector3.new(hrp.AssemblyLinearVelocity.X, math.sin(t * 3) * 2.5, hrp.AssemblyLinearVelocity.Z)
	end)

	state.cardsCon = RunService.Heartbeat:Connect(function(dt)
		t += dt
		if math.floor(t * 8) % 3 ~= 0 then return end
		local card = addEffect(Instance.new("Part"), 1.1)
		card.Anchored = true
		card.CanCollide = false
		card.Material = Enum.Material.Neon
		card.Color = Color3.fromRGB(255, 36, 119)
		card.Size = Vector3.new(1.5, 0.1, 2)
		card.CFrame = hrp.CFrame * CFrame.new(math.random(-4, 4), math.random(-1, 3), math.random(-4, 4)) * CFrame.Angles(0, math.rad(math.random(0, 360)), 0)
		card.Parent = workspace
	end)
end

local function blackHoleAbility()
	local target, root, hum = getTargetFromMouse(80)
	if not target or not root or not hum then
		notify("Card Black Hole", "No target found", 2)
		return
	end

	local swirl = addEffect(Instance.new("Part"), 1.4)
	swirl.Anchored = true
	swirl.CanCollide = false
	swirl.Shape = Enum.PartType.Cylinder
	swirl.Material = Enum.Material.Neon
	swirl.Color = Color3.fromRGB(25, 25, 25)
	swirl.Size = Vector3.new(1, 12, 12)
	swirl.CFrame = CFrame.new(root.Position) * CFrame.Angles(0, 0, math.rad(90))
	swirl.Parent = workspace

	for i = 1, 5 do
		if target:IsA("Player") then
			sendGGCMDCommand("bring " .. target.Name)
			sendGGCMDCommand("fling " .. target.Name)
		else
			local neck = target:FindFirstChild("Head") and target.Head:FindFirstChild("Neck")
			if neck then deleteViaGGCMD(neck) end
		end
		task.wait(0.07)
	end
	if target:IsA("Player") then
		sendGGCMDCommand("kill " .. target.Name)
	end
end

local function superiorLightning()
	local target, root = getTargetFromMouse(120)
	if not target or not root then
		notify("Superior Lightning", "Aim closer to a target", 2)
		return
	end

	for i = 1, 3 do
		local bolt = addEffect(Instance.new("Part"), 0.25)
		bolt.Anchored = true
		bolt.CanCollide = false
		bolt.Material = Enum.Material.Neon
		bolt.Color = Color3.fromRGB(230, 230, 255)
		bolt.Size = Vector3.new(0.3, 18, 0.3)
		bolt.CFrame = CFrame.new(root.Position + Vector3.new(math.random(-2,2), 9, math.random(-2,2)))
		bolt.Parent = workspace
	end

	if target:IsA("Player") then
		sendGGCMDCommand("freeze " .. target.Name)
		task.wait(0.1)
		sendGGCMDCommand("kill " .. target.Name)
	else
		local neck = target:FindFirstChild("Head") and target.Head:FindFirstChild("Neck")
		if neck then deleteViaGGCMD(neck) end
	end
end

local function superiorBomb()
	local _, _, myRoot = getCharacter()
	if not myRoot then return end
	local blast = addEffect(Instance.new("Explosion"), 0.2)
	blast.Position = myRoot.Position
	blast.BlastRadius = 16
	blast.BlastPressure = 0
	blast.Parent = workspace

	for _, plr in ipairs(Players:GetPlayers()) do
		if plr ~= localPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
			local dist = (plr.Character.HumanoidRootPart.Position - myRoot.Position).Magnitude
			if dist <= 20 then
				sendGGCMDCommand("bring " .. plr.Name)
				sendGGCMDCommand("kill " .. plr.Name)
			end
		end
	end
end

local function spawnMinion()
	if state.lifeMinionUsed then
		notify("Ability", "Minion already used this life", 2)
		return
	end
	state.lifeMinionUsed = true

	local _, _, myRoot = getCharacter()
	if not myRoot then return end
	local minion = addEffect(Instance.new("Part"), 20)
	minion.Name = "XesterHammerMinion"
	minion.Size = Vector3.new(2, 3, 2)
	minion.Material = Enum.Material.Neon
	minion.Color = Color3.fromRGB(90, 90, 90)
	minion.Anchored = false
	minion.CanCollide = true
	minion.CFrame = myRoot.CFrame * CFrame.new(2, 1.5, -2)
	minion.Parent = workspace

	local bodyVel = Instance.new("BodyVelocity")
	bodyVel.MaxForce = Vector3.new(9e5, 2e5, 9e5)
	bodyVel.Parent = minion

	task.spawn(function()
		local stopAt = tick() + 18
		while minion.Parent and tick() < stopAt do
			local best, bestRoot, _, bestDist
			for _, plr in ipairs(Players:GetPlayers()) do
				if plr == localPlayer then continue end
				local c = plr.Character
				local r = c and c:FindFirstChild("HumanoidRootPart")
				if r then
					local d = (r.Position - minion.Position).Magnitude
					if not bestDist or d < bestDist then
						best, bestRoot, bestDist = plr, r, d
					end
				end
			end
			if best and bestRoot then
				local dir = (bestRoot.Position - minion.Position)
				bodyVel.Velocity = dir.Unit * 42 + Vector3.new(0, 8, 0)
				if dir.Magnitude < 5 then
					sendGGCMDCommand("kill " .. best.Name)
					task.wait(0.35)
				end
			else
				bodyVel.Velocity = Vector3.new(0, 0, 0)
			end
			task.wait(0.08)
		end
	end)
end

local function createTool(name, tip, onActivate)
	local tool = Instance.new("Tool")
	tool.RequiresHandle = false
	tool.CanBeDropped = false
	tool.Name = name
	tool.ToolTip = tip
	tool.Activated:Connect(onActivate)
	tool.Parent = localPlayer:WaitForChild("Backpack")
	table.insert(state.tools, tool)
	return tool
end

createTool("Card Black Hole", "Suck + kill nearest aimed target", blackHoleAbility)
createTool("Superior Bomb", "Pull + explode around you", superiorBomb)
createTool("Ability: Hammer Minion", "Spawn minion once per life", spawnMinion)

UserInputService.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	if input.KeyCode == state.lightningKey then
		superiorLightning()
	end
	if input.KeyCode == Enum.KeyCode.E then
		blackHoleAbility()
	end
end)

localPlayer.CharacterAdded:Connect(function()
	state.lifeMinionUsed = false
	task.delay(1, function()
		applyXesterStyle()
		startFloatingAndCards()
	end)
end)

applyXesterStyle()
startFloatingAndCards()
notify("Xester V2", "Loaded. Tools in backpack, Y=Lightning, E=Black Hole", 5)
