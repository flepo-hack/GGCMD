-- Freezer Addon for GGCMD
-- Run this only after GGCMD is already executed.

local Players = game:GetService("Players")
local TextChatService = game:GetService("TextChatService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Debris = game:GetService("Debris")

local localPlayer = Players.LocalPlayer
local playerGui = localPlayer:FindFirstChildOfClass("PlayerGui")
local ggcmdGui = playerGui and playerGui:FindFirstChild("GGCMD")

if not ggcmdGui then
	warn("[Freezer Addon] GGCMD GUI not found. Execute GGCMD first.")
	return
end

local genv = (getgenv and getgenv()) or _G
if not genv.foundRemote then
	warn("[Freezer Addon] GGCMD remote not found (getgenv().foundRemote). Execute GGCMD first.")
	return
end

local PREFIX = ";"
local FREEZER_TAG = "GGCMD_FREEZER_ADDON"
local freezerState = {
	enabled = false,
	original = {},
	tools = {},
	effects = {}
}

local function notify(title, text, duration)
	pcall(function()
		game:GetService("StarterGui"):SetCore("SendNotification", {
			Title = title,
			Text = text,
			Duration = duration or 3
		})
	end)
end

local function trackEffect(inst, life)
	table.insert(freezerState.effects, inst)
	if life and life > 0 then
		Debris:AddItem(inst, life)
	end
	return inst
end

local function clearEffects()
	for _, v in ipairs(freezerState.effects) do
		if v and v.Parent then
			v:Destroy()
		end
	end
	table.clear(freezerState.effects)
end

local function clearTools()
	for _, tool in ipairs(freezerState.tools) do
		if tool and tool.Parent then
			tool:Destroy()
		end
	end
	table.clear(freezerState.tools)
end

local function sendGGCMDCommand(raw)
	local msg = PREFIX .. raw
	if TextChatService.ChatVersion == Enum.ChatVersion.TextChatService then
		local channel = TextChatService.TextChannels:FindFirstChild("RBXGeneral")
		if channel then
			pcall(function()
				channel:SendAsync(msg)
			end)
			return
		end
	end

	local legacy = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
	local say = legacy and legacy:FindFirstChild("SayMessageRequest")
	if say then
		pcall(function()
			say:FireServer(msg, "All")
		end)
	end
end

local function getCharacter()
	local char = localPlayer.Character or localPlayer.CharacterAdded:Wait()
	local hrp = char:FindFirstChild("HumanoidRootPart")
	return char, hrp
end

local function applyFreezerLook()
	local char = getCharacter()
	if not char then return end

	freezerState.original = {}
	for _, obj in ipairs(char:GetDescendants()) do
		if obj:IsA("BasePart") then
			freezerState.original[obj] = {
				Material = obj.Material,
				Color = obj.Color,
				Transparency = obj.Transparency
			}
			obj.Material = Enum.Material.Glass
			obj.Color = Color3.fromRGB(182, 238, 255)
			obj.Transparency = math.clamp(obj.Transparency + 0.06, 0, 0.35)
		end
	end

	local head = char:FindFirstChild("Head")
	if head then
		local breath = Instance.new("ParticleEmitter")
		breath.Name = FREEZER_TAG .. "_BREATH"
		breath.Texture = "rbxassetid://7712212245"
		breath.Rate = 12
		breath.Speed = NumberRange.new(0.8, 1.8)
		breath.Lifetime = NumberRange.new(0.5, 1)
		breath.Size = NumberSequence.new(0.18, 0)
		breath.Color = ColorSequence.new(Color3.fromRGB(220, 248, 255))
		breath.Parent = head
		trackEffect(breath)
	end
end

local function restoreLook()
	for part, data in pairs(freezerState.original) do
		if part and part.Parent then
			part.Material = data.Material
			part.Color = data.Color
			part.Transparency = data.Transparency
		end
	end
	freezerState.original = {}
end

local function nearestTarget(maxDistance)
	local _, hrp = getCharacter()
	if not hrp then return nil end

	local best, bestDist
	for _, plr in ipairs(Players:GetPlayers()) do
		if plr ~= localPlayer and plr.Character then
			local root = plr.Character:FindFirstChild("HumanoidRootPart")
			if root then
				local dist = (root.Position - hrp.Position).Magnitude
				if dist <= maxDistance and (not bestDist or dist < bestDist) then
					best, bestDist = plr, dist
				end
			end
		end
	end
	return best
end

local function doIceSlide()
	if not freezerState.enabled then return end
	local char, hrp = getCharacter()
	if not char or not hrp then return end

	local hatch = trackEffect(Instance.new("Part"), 1.8)
	hatch.Name = FREEZER_TAG .. "_HATCH"
	hatch.Anchored = true
	hatch.CanCollide = false
	hatch.Material = Enum.Material.Neon
	hatch.Color = Color3.fromRGB(195, 245, 255)
	hatch.Size = Vector3.new(2.3, 0.2, 1.6)
	hatch.CFrame = hrp.CFrame * CFrame.new(0, -2.6, -1)
	hatch.Parent = workspace

	local ice = trackEffect(Instance.new("Part"), 2.2)
	ice.Name = FREEZER_TAG .. "_ICE"
	ice.Anchored = true
	ice.CanCollide = false
	ice.Material = Enum.Material.Ice
	ice.Color = Color3.fromRGB(180, 235, 255)
	ice.Transparency = 0.15
	ice.Size = Vector3.new(7, 0.2, 4)
	ice.CFrame = hrp.CFrame * CFrame.new(0, -3, -2)
	ice.Parent = workspace

	hrp.CFrame = hrp.CFrame + hrp.CFrame.LookVector * 2
	hrp.AssemblyLinearVelocity = hrp.CFrame.LookVector * 85
	task.delay(0.45, function()
		if hrp and hrp.Parent then
			hrp.AssemblyLinearVelocity = Vector3.zero
		end
	end)
end

local function doEat()
	if not freezerState.enabled then return end
	local char, hrp = getCharacter()
	if not char or not hrp then return end

	local target = nearestTarget(8)
	if not target then
		notify("Freezer", "Ei targettia tarpeeksi lähellä", 2)
		return
	end

	local tChar = target.Character
	local tHead = tChar and tChar:FindFirstChild("Head")
	if tHead then
		local bite = trackEffect(Instance.new("Part"), 1)
		bite.Name = FREEZER_TAG .. "_BITE"
		bite.Anchored = true
		bite.CanCollide = false
		bite.Material = Enum.Material.Neon
		bite.Color = Color3.fromRGB(215, 250, 255)
		bite.Shape = Enum.PartType.Ball
		bite.Size = Vector3.new(1.3, 1.3, 1.3)
		bite.CFrame = tHead.CFrame
		bite.Parent = workspace
	end

	-- Uses GGCMD chat command pipeline so it can run through its own command/backdoor flow.
	sendGGCMDCommand("wither " .. target.Name .. " 0.2")
	task.delay(0.7, function()
		sendGGCMDCommand("eat " .. target.Name)
	end)
end

local function makeTool(name, color, onActivated)
	local backpack = localPlayer:FindFirstChildOfClass("Backpack")
	if not backpack then return end

	local tool = Instance.new("Tool")
	tool.Name = name
	tool.RequiresHandle = true
	tool.CanBeDropped = false

	local handle = Instance.new("Part")
	handle.Name = "Handle"
	handle.Material = Enum.Material.Neon
	handle.Color = color
	handle.Size = Vector3.new(1, 1, 2)
	handle.CanCollide = false
	handle.Parent = tool

	tool.Activated:Connect(onActivated)
	tool.Parent = backpack
	table.insert(freezerState.tools, tool)
end

local function enableFreezer()
	if freezerState.enabled then
		clearEffects()
		clearTools()
		restoreLook()
	end

	freezerState.enabled = true
	applyFreezerLook()
	makeTool("Ice Slide", Color3.fromRGB(173, 232, 255), doIceSlide)
	makeTool("Eat", Color3.fromRGB(220, 245, 255), doEat)
	notify("Freezer", "Freezer mode ON (Ice Slide + Eat)", 3)
end

local function disableFreezer()
	freezerState.enabled = false
	clearTools()
	clearEffects()
	restoreLook()
	notify("Freezer", "Freezer mode OFF", 2)
end

-- auto-enable as requested
enableFreezer()

-- optional cleanup commands via chat keywords from local player
localPlayer.Chatted:Connect(function(msg)
	local m = msg:lower()
	if m == PREFIX .. "unfreezeraddon" then
		disableFreezer()
	elseif m == PREFIX .. "freezeraddon" then
		enableFreezer()
	end
end)
