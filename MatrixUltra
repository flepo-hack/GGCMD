-- MATRIX ULTRA BEAM V8.1
-- Delta/mobile friendly visual script:
-- style swap (black clothes + sunglasses), matrix terminals, lean-back pose,
-- right hand behind back while walking/idle, double tap beam summon.

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local InsertService = game:GetService("InsertService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Debris = game:GetService("Debris")

local player = Players.LocalPlayer
if not player then return end

local camera = workspace.CurrentCamera
local mouse = player:GetMouse()

local character, humanoid, rootPart
local tool, bodyColors
local terminals = {}
local updateConn, inputConn

local leftShoulderDefault, rightShoulderDefault
local rootJoint, rootJointDefault

local DOUBLE_TAP_WINDOW = 0.35
local lastTapTime = 0
local lastTouchPos = Vector2.zero
local tickWave = 0

local MATRIX_CHARS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ./\\|#$%&*+-=()[]{}<>?!"
local ASSETS = {
    Shirt = "rbxassetid://14238839317",
    Pants = "rbxassetid://7150805858",
    GlassesAsset = 6040339082,
}

local function pickChar()
    local i = math.random(1, #MATRIX_CHARS)
    return MATRIX_CHARS:sub(i, i)
end

local function destroyTerminals()
    for _, term in ipairs(terminals) do
        if term.part then term.part:Destroy() end
    end
    table.clear(terminals)
end

local function resetPose()
    if rootJoint and rootJointDefault then
        rootJoint.C0 = rootJointDefault
    end

    local torso = character and (character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso"))
    if not torso then return end

    local leftShoulder = torso:FindFirstChild("Left Shoulder")
    local rightShoulder = torso:FindFirstChild("Right Shoulder")

    if leftShoulder and leftShoulderDefault then leftShoulder.C0 = leftShoulderDefault end
    if rightShoulder and rightShoulderDefault then rightShoulder.C0 = rightShoulderDefault end
end

local function cleanup()
    if inputConn then inputConn:Disconnect(); inputConn = nil end
    if updateConn then updateConn:Disconnect(); updateConn = nil end

    resetPose()

    if bodyColors then
        bodyColors:Destroy()
        bodyColors = nil
    end

    destroyTerminals()
end

local function createGroundCracks(position)
    local ray = workspace:Raycast(position + Vector3.new(0, 5, 0), Vector3.new(0, -40, 0))
    if not ray then return end

    local hit = ray.Position + Vector3.new(0, 0.05, 0)
    for i = 1, 14 do
        local angle = ((i - 1) / 14) * (math.pi * 2)

        local crack = Instance.new("Part")
        crack.Name = "MatrixCrackV8"
        crack.Anchored = true
        crack.CanCollide = false
        crack.Material = Enum.Material.Slate
        crack.Color = Color3.fromRGB(24, 28, 24)
        crack.Transparency = 0.25
        crack.Size = Vector3.new(0.18, 0.04, 0.8)
        crack.CFrame = CFrame.lookAt(hit, hit + Vector3.new(math.cos(angle), 0, math.sin(angle)))
            * CFrame.Angles(math.rad(90), 0, 0)
        crack.Parent = workspace

        TweenService:Create(crack, TweenInfo.new(0.35, Enum.EasingStyle.Quad), {
            Size = Vector3.new(0.26, 0.04, math.random(7, 16)),
            Transparency = 0.5,
        }):Play()

        TweenService:Create(crack, TweenInfo.new(1.1, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {
            Transparency = 1,
        }):Play()

        Debris:AddItem(crack, 1.4)
    end
end

local function createImpact(position)
    local ring = Instance.new("Part")
    ring.Shape = Enum.PartType.Cylinder
    ring.Anchored = true
    ring.CanCollide = false
    ring.Material = Enum.Material.Neon
    ring.Color = Color3.fromRGB(25, 255, 100)
    ring.Transparency = 0.12
    ring.Size = Vector3.new(0.1, 2, 2)
    ring.CFrame = CFrame.new(position) * CFrame.Angles(0, 0, math.rad(90))
    ring.Parent = workspace

    TweenService:Create(ring, TweenInfo.new(0.35, Enum.EasingStyle.Quint), {
        Size = Vector3.new(0.1, 30, 30),
        Transparency = 1,
    }):Play()

    local smoke = Instance.new("ParticleEmitter")
    smoke.Texture = "rbxassetid://296874371"
    smoke.Color = ColorSequence.new(Color3.fromRGB(20, 230, 100), Color3.fromRGB(6, 70, 32))
    smoke.Size = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 3),
        NumberSequenceKeypoint.new(1, 8.5),
    })
    smoke.Lifetime = NumberRange.new(0.8, 1.6)
    smoke.Speed = NumberRange.new(5, 14)
    smoke.SpreadAngle = Vector2.new(180, 180)
    smoke.Rate = 0
    smoke.Parent = ring
    smoke:Emit(130)

    local sparks = Instance.new("ParticleEmitter")
    sparks.Texture = "rbxassetid://241650934"
    sparks.Color = ColorSequence.new(Color3.fromRGB(10, 255, 95))
    sparks.Lifetime = NumberRange.new(0.2, 0.5)
    sparks.Speed = NumberRange.new(28, 52)
    sparks.SpreadAngle = Vector2.new(60, 60)
    sparks.Rate = 0
    sparks.Parent = ring
    sparks:Emit(220)

    createGroundCracks(position)
    Debris:AddItem(ring, 1.2)
end

local function castBeam(targetPosition)
    local sky = targetPosition + Vector3.new(0, 260, 0)

    local startPart = Instance.new("Part")
    startPart.Anchored = true
    startPart.CanCollide = false
    startPart.Transparency = 1
    startPart.Size = Vector3.new(2, 2, 2)
    startPart.CFrame = CFrame.new(sky)
    startPart.Parent = workspace

    local endPart = Instance.new("Part")
    endPart.Anchored = true
    endPart.CanCollide = false
    endPart.Material = Enum.Material.Neon
    endPart.Shape = Enum.PartType.Ball
    endPart.Color = Color3.fromRGB(15, 255, 90)
    endPart.Transparency = 0
    endPart.Size = Vector3.new(6, 6, 6)
    endPart.CFrame = CFrame.new(targetPosition)
    endPart.Parent = workspace

    local a0 = Instance.new("Attachment", startPart)
    local a1 = Instance.new("Attachment", endPart)

    local beam = Instance.new("Beam")
    beam.Attachment0 = a0
    beam.Attachment1 = a1
    beam.Color = ColorSequence.new(Color3.fromRGB(20, 255, 105))
    beam.Texture = "rbxassetid://499487295"
    beam.TextureLength = 1.5
    beam.TextureSpeed = -28
    beam.Width0 = 10
    beam.Width1 = 15
    beam.LightEmission = 1
    beam.FaceCamera = true
    beam.Segments = 30
    beam.Transparency = NumberSequence.new(0)
    beam.Parent = workspace

    TweenService:Create(endPart, TweenInfo.new(0.2), {
        Size = Vector3.new(20, 20, 20),
        Transparency = 0.3,
    }):Play()

    TweenService:Create(endPart, TweenInfo.new(0.58, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
        Transparency = 1,
    }):Play()

    createImpact(targetPosition)

    Debris:AddItem(startPart, 1)
    Debris:AddItem(endPart, 1)
    Debris:AddItem(beam, 1)
end

local function screenToWorld(screenPos)
    local ray = camera:ViewportPointToRay(screenPos.X, screenPos.Y)
    local hit = workspace:Raycast(ray.Origin, ray.Direction * 2200)
    if hit then return hit.Position end
    return ray.Origin + ray.Direction * 160
end

local function applyLook()
    for _, child in ipairs(character:GetChildren()) do
        if child:IsA("Shirt") or child:IsA("Pants") or child:IsA("BodyColors") then
            child:Destroy()
        end
    end

    local shirt = Instance.new("Shirt")
    shirt.ShirtTemplate = ASSETS.Shirt
    shirt.Parent = character

    local pants = Instance.new("Pants")
    pants.PantsTemplate = ASSETS.Pants
    pants.Parent = character

    bodyColors = Instance.new("BodyColors")
    bodyColors.HeadColor3 = Color3.fromRGB(22, 22, 22)
    bodyColors.TorsoColor3 = Color3.fromRGB(10, 10, 10)
    bodyColors.LeftArmColor3 = Color3.fromRGB(22, 22, 22)
    bodyColors.RightArmColor3 = Color3.fromRGB(22, 22, 22)
    bodyColors.LeftLegColor3 = Color3.fromRGB(8, 8, 8)
    bodyColors.RightLegColor3 = Color3.fromRGB(8, 8, 8)
    bodyColors.Parent = character

    task.spawn(function()
        local ok, asset = pcall(InsertService.LoadAsset, InsertService, ASSETS.GlassesAsset)
        if ok and asset then
            local glasses = asset:FindFirstChildOfClass("Accessory")
            if glasses and character and character.Parent then
                glasses.Parent = character
            end
            asset:Destroy()
        end
    end)
end

local function setupPoseMotors()
    local torso = character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso")
    if not torso then return end

    local leftShoulder = torso:FindFirstChild("Left Shoulder")
    local rightShoulder = torso:FindFirstChild("Right Shoulder")

    if leftShoulder then leftShoulderDefault = leftShoulder.C0 end
    if rightShoulder then rightShoulderDefault = rightShoulder.C0 end

    rootJoint = torso:FindFirstChild("RootJoint") or torso:FindFirstChild("Waist")
    if not rootJoint and rootPart then rootJoint = rootPart:FindFirstChild("RootJoint") end
    if rootJoint then rootJointDefault = rootJoint.C0 end
end

local function buildTerminals()
    for i = 1, 3 do
        local part = Instance.new("Part")
        part.Name = "MatrixPanelV8_" .. i
        part.Anchored = true
        part.CanCollide = false
        part.Material = Enum.Material.Plastic
        part.Color = Color3.new(0, 0, 0)
        part.Transparency = 0.3
        part.Size = Vector3.new(5.4, 7.2, 0.1)
        part.Parent = workspace

        local terminal = {
            part = part,
            offset = Vector3.new((i - 2) * 6.1, 2 + (math.sin(i) * 0.6), -12),
            glyphs = {},
        }

        for _, face in ipairs({Enum.NormalId.Front, Enum.NormalId.Back}) do
            local gui = Instance.new("SurfaceGui")
            gui.Face = face
            gui.AlwaysOnTop = true
            gui.LightInfluence = 0
            gui.Parent = part

            local bg = Instance.new("Frame")
            bg.Size = UDim2.fromScale(1, 1)
            bg.BackgroundColor3 = Color3.new(0, 0, 0)
            bg.BackgroundTransparency = 0.2
            bg.BorderSizePixel = 0
            bg.Parent = gui

            local cols, rows = 18, 44
            for col = 1, cols do
                for row = 1, rows do
                    local label = Instance.new("TextLabel")
                    label.Size = UDim2.new(1 / cols, 0, 1 / rows, 0)
                    label.Position = UDim2.new((col - 1) / cols, 0, (row - 1) / rows, 0)
                    label.BackgroundTransparency = 1
                    label.Text = ""
                    label.TextColor3 = Color3.fromRGB(0, 255, 90)
                    label.TextSize = 16
                    label.Font = Enum.Font.Code
                    label.Parent = bg

                    terminal.glyphs[#terminal.glyphs + 1] = {
                        label = label,
                        col = col,
                        flow = math.random(0, 1000),
                        glow = 0,
                    }
                end
            end
        end

        terminals[#terminals + 1] = terminal
    end
end

local function setupEffects()
    cleanup()
    applyLook()
    setupPoseMotors()
    buildTerminals()
end

local function updateVisuals(dt)
    if not (rootPart and humanoid and rootPart.Parent) then return end

    tickWave += dt * 3
    local moving = humanoid.MoveDirection.Magnitude > 0.05

    local tilt = moving and -12 or -16
    local wobble = math.sin(tickWave) * (moving and 1.4 or 0.8)

    if rootJoint and rootJointDefault then
        rootJoint.C0 = rootJointDefault * CFrame.Angles(math.rad(tilt + wobble), 0, 0)
    end

    local torso = character and (character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso"))
    if torso then
        local leftShoulder = torso:FindFirstChild("Left Shoulder")
        local rightShoulder = torso:FindFirstChild("Right Shoulder")

        if leftShoulder and leftShoulderDefault then
            leftShoulder.C0 = leftShoulderDefault * CFrame.Angles(math.rad(-4), 0, math.rad(-2))
        end

        if rightShoulder and rightShoulderDefault then
            local behindBack = rightShoulderDefault
                * CFrame.new(0.1, 0.06, moving and 0.3 or 0.4)
                * CFrame.Angles(math.rad(moving and 46 or 54), 0, math.rad(moving and 22 or 28))
            rightShoulder.C0 = behindBack
        end
    end

    local baseCF = rootPart.CFrame
    local cameraPos = camera and camera.CFrame.Position or (baseCF.Position + baseCF.LookVector * 10)

    for i, term in ipairs(terminals) do
        local bob = math.sin((tickWave * 1.5) + i) * 0.27
        local pos = (baseCF * CFrame.new(term.offset.X, term.offset.Y + bob, term.offset.Z)).Position
        term.part.CFrame = CFrame.lookAt(pos, cameraPos)

        for _, g in ipairs(term.glyphs) do
            local stream = (os.clock() * 34 + g.col * 11) % 1000
            g.flow = (g.flow + dt * 58) % 1000
            local dist = math.abs(stream - g.flow)
            g.glow = math.max(0, g.glow - dt * 4)

            if dist < 42 then
                g.glow = 1
                g.label.Text = pickChar()
                g.label.TextTransparency = 1 - (dist / 42)
            else
                g.label.Text = ""
                g.label.TextTransparency = 1 - (g.glow * 0.35)
            end
        end
    end
end

local function fireDoubleTap(screenPos)
    local worldPos = UserInputService.TouchEnabled and screenToWorld(screenPos) or mouse.Hit.Position
    castBeam(worldPos)
end

local function bindInput()
    inputConn = UserInputService.InputBegan:Connect(function(input, processed)
        if processed then return end

        local t = input.UserInputType
        if t ~= Enum.UserInputType.MouseButton1 and t ~= Enum.UserInputType.Touch then return end

        local now = tick()
        local isDouble = (now - lastTapTime) <= DOUBLE_TAP_WINDOW
        lastTapTime = now

        local pos = input.Position and Vector2.new(input.Position.X, input.Position.Y) or lastTouchPos
        if t == Enum.UserInputType.Touch and input.Position then
            lastTouchPos = Vector2.new(input.Position.X, input.Position.Y)
        end

        if isDouble then
            fireDoubleTap(pos)
            lastTapTime = 0
        end
    end)
end

local function createTool()
    tool = Instance.new("Tool")
    tool.Name = "Matrix Beam"
    tool.RequiresHandle = false
    tool.CanBeDropped = true
    tool.Parent = player.Backpack

    tool.Equipped:Connect(function()
        character = player.Character or player.CharacterAdded:Wait()
        humanoid = character:WaitForChild("Humanoid")
        rootPart = character:WaitForChild("HumanoidRootPart")

        setupEffects()
        bindInput()

        updateConn = RunService.Heartbeat:Connect(updateVisuals)
    end)

    tool.Unequipped:Connect(cleanup)
end

player.CharacterAdded:Connect(function()
    if tool then tool.Parent = player.Backpack end
end)

createTool()
print("âœ… MATRIX ULTRA V8.1 READY | Equip tool + double tap/click")
